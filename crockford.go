// Package crockford implements the Crockford base 32 encoding
//
// See https://www.crockford.com/base32.html
package crockford

import (
	"crypto/md5"
	"crypto/rand"
	"encoding/base32"
	"slices"
	"time"
)

// Base32 alphabets
const (
	LowercaseAlphabet = "0123456789abcdefghjkmnpqrstvwxyz"
	UppercaseAlphabet = "0123456789ABCDEFGHJKMNPQRSTVWXYZ"
)

// Base32 encodings
var (
	Lower = base32.NewEncoding(LowercaseAlphabet).WithPadding(base32.NoPadding)
	Upper = base32.NewEncoding(UppercaseAlphabet).WithPadding(base32.NoPadding)
)

// Buffer lengths
const (
	LenTime   = 8  // length returned by AppendTime
	LenRandom = 8  // length returned by AppendRandom
	LenMD5    = 26 // length returned by AppendMD5
)

// Time encodes the Unix time as a 40-bit number. The resulting string is big endian
// and suitable for lexicographic sorting.
func Time(e *base32.Encoding, t time.Time) string {
	return string(AppendTime(e, t, nil))
}

// AppendTime appends onto dst LenTime bytes with the Unix time encoded as a 40-bit number.
// The resulting slice is big endian and suitable for lexicographic sorting.
func AppendTime(e *base32.Encoding, t time.Time, dst []byte) []byte {
	ut := t.Unix()
	var src [5]byte
	src[0] = byte(ut >> 32)
	src[1] = byte(ut >> 24)
	src[2] = byte(ut >> 16)
	src[3] = byte(ut >> 8)
	src[4] = byte(ut)
	return e.AppendEncode(dst, src[:])
}

func normUpper(c byte) byte {
	switch c {
	case '0', 'O', 'o':
		return '0'
	case '1', 'I', 'i', 'L', 'l':
		return '1'
	case '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z', '*', '~', '$', '=', 'U':
		return c
	case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z', 'u':
		return c + 'A' - 'a'
	}
	return 0
}

// Normalized returns a normalized version of Crockford encoded bytes of src
// onto dst and returns the resulting slice. It replaces I and L with 1, o with 0,
// and removes invalid characters such as hyphens. The resulting slice is uppercase.
func Normalized(s string) string {
	return string(AppendNormalized(nil, []byte(s)))
}

// AppendNormalized appends a normalized version of Crockford encoded bytes of src
// onto dst and returns the resulting slice. It replaces I and L with 1, o with 0,
// and removes invalid characters such as hyphens. The resulting slice is uppercase.
func AppendNormalized(dst, src []byte) []byte {
	dst = slices.Grow(dst, len(src))
	for _, c := range src {
		if r := normUpper(c); r != 0 {
			dst = append(dst, r)
		}
	}
	return dst
}

// Random returns LenRandom (8) encoded bytes generated by crypto/rand.
func Random(e *base32.Encoding) string {
	return string(AppendRandom(e, nil))
}

// AppendRandom appends LenRandom (8) encoded bytes generated by crypto/rand onto dst.
func AppendRandom(e *base32.Encoding, dst []byte) []byte {
	// 5 bytes -> 8 base32 characters
	dst = slices.Grow(dst, LenRandom)
	// Use the tail of dst as scratch
	src := dst[len(dst) : len(dst)+5]
	if _, err := rand.Read(src); err != nil {
		panic(err)
	}
	return e.AppendEncode(dst, src)
}

// MD5 returns encoded bytes generated by MD5 hashing src.
func MD5(e *base32.Encoding, src []byte) string {
	return string(AppendMD5(e, nil, src))
}

// AppendMD5 appends LenMD (26) encoded bytes generated by MD5 hashing src onto dst.
func AppendMD5(e *base32.Encoding, dst, src []byte) []byte {
	//16 bytes -> 26 base32 characters
	var buf [md5.Size]byte

	h := md5.New()
	h.Write(src)
	h.Sum(buf[:0])
	return e.AppendEncode(dst, buf[:])
}

// Partition s with hyphens ("-") to every gap bytes to increase readability.
// Partition is not Unicode aware because it is made to work with encoded strings.
func Partition(s string, gap int) string {
	return string(AppendPartition(nil, []byte(s), gap))
}

// AppendPartition appends onto dst the result of
// partitioning src with hyphens ("-") every gap bytes.
func AppendPartition(dst, src []byte, gap int) []byte {
	if gap < 1 {
		panic("invalid gap")
	}
	if len(src) < 1 {
		return dst
	}
	// figure out how many hyphens to insert
	gaps := len(src) / gap
	rem := len(src) % gap
	if rem == 0 && gaps > 0 {
		gaps--
	}
	// reserve space
	n := gaps + len(src)
	dst = slices.Grow(dst, n)
	r := dst[:0]

	// copy bytes inserting hyphens along the way
	sinceHyphen := 0
	for _, c := range src {
		if sinceHyphen == gap {
			r = append(r, '-')
			sinceHyphen = 0
		}
		r = append(r, c)
		sinceHyphen++
	}
	return r
}
